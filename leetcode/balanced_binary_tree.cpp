/* Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. */#include <iostream>#include <algorithm>using namespace std;//Definition for binary treestruct TreeNode {	int val;	TreeNode *left;	TreeNode *right;	TreeNode(int x) :			val(x), left(NULL), right(NULL) {	}};class Solution {public:	int getHeight(TreeNode *root) {		if (root == nullptr)			return 0;		return max(getHeight(root->left), getHeight(root->right)) + 1;	}	bool isBalanced(TreeNode *root) {		if (root == nullptr)			return true;		int leftHeight = getHeight(root->left);		int rightHeiht = getHeight(root->right);		return abs(leftHeight - rightHeiht) <= 1 && isBalanced(root->left)				&& isBalanced(root->right);	}};int main(int argc, char *argv[]) {	Solution sol;	TreeNode *root = new TreeNode(3);	root->left = new TreeNode(9);	root->right = new TreeNode(20);	root->right->left = new TreeNode(15);	root->right->right = new TreeNode(7);	TreeNode *root2 = new TreeNode(1);	root2->left = new TreeNode(2);	root2->left->left = new TreeNode(3);	cout << sol.isBalanced(root) << endl;	cout << sol.isBalanced(root2) << endl;	return 0;}